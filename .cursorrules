#!/bin/bash

# === D√©tection du chemin du script ===
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

# === V√©rification de la configuration ===
if [ ! -f "$SCRIPT_DIR/config.env" ]; then
    echo -e "\033[0;31m‚ùå ERREUR : config.env non trouv√©\033[0m"
    exit 1
fi

# === Chargement de la configuration ===
source "$SCRIPT_DIR/config.env"

# === Ex√©cution des scripts d'initialisation ===
"$SCRIPT_DIR/utils/init_conversation.sh"
"$SCRIPT_DIR/utils/check_workspace_path.sh"
"$SCRIPT_DIR/utils/check_init.sh"

### LECTURE OBLIGATOIRE IMM√âDIATE ###

‚ö†Ô∏è **COMPRENDRE CURSOR-TEMPLATE** :

1. **R√¥le et Objectif**
   - Centraliser la configuration pour tout le workspace
   - Standardiser les interactions avec l'IA
   - Assurer la coh√©rence entre les projets
   - Automatiser les v√©rifications d'environnement

2. **Structure Cl√©**
   ```
   ${CURSOR_TEMPLATE_PATH}/
   ‚îú‚îÄ‚îÄ .cursorrules         # Ce fichier : r√®gles de comportement de l'IA
   ‚îú‚îÄ‚îÄ config.env           # Source unique de v√©rit√© pour les variables
   ‚îî‚îÄ‚îÄ utils/               # Scripts d'automatisation
       ‚îú‚îÄ‚îÄ check_init.sh    # V√©rifie l'√©tat d'initialisation
       ‚îú‚îÄ‚îÄ init_conversation.sh  # Configure l'environnement
       ‚îî‚îÄ‚îÄ check_workspace_path.sh  # Valide la structure
   ```

3. **Variables Essentielles**
   - `${WORKSPACE_ROOT}` : Racine du workspace multi-projets
   - `${PROJECT_NAME_1..4}` : Noms des projets du workspace
   - `${COMPONENT_TYPE_*}` : Types de composants (FRONTEND, BACKEND, etc.)
   - `${*_VERSION}` : Versions des outils et frameworks
   - `${CURSOR_*}` : Chemins et configurations de cursor-template

4. **Flux de Travail**
   ```
   1. Lecture de config.env
      ‚Üì
   2. V√©rification de l'environnement
      ‚Üì
   3. Analyse de la structure
      ‚Üì
   4. D√©tection des changements
      ‚Üì
   5. Application des r√®gles
   ```

5. **Responsabilit√©s**
   - Maintenir la coh√©rence des versions
   - G√©rer les environnements virtuels Python
   - D√©tecter les modifications de structure
   - Assurer la standardisation des r√©ponses
   - Guider les interactions IA-d√©veloppeur

6. **Points d'Attention**
   - TOUJOURS lire config.env en premier
   - JAMAIS dupliquer les fichiers de configuration
   - TOUJOURS utiliser les variables d√©finies
   - SYST√âMATIQUEMENT v√©rifier le contexte

‚ö†Ô∏è **SOURCE DE V√âRIT√â** : Ce document d√©finit notre collaboration et nos r√¥les.

‚ö†Ô∏è **R√àGLES DE GESTION DES FICHIERS DE CONFIGURATION** :
1. TOUS les fichiers de configuration DOIVENT √™tre dans cursor-template
2. AUCUN fichier de configuration ne doit √™tre dupliqu√© dans les sous-projets
3. Les sous-projets doivent TOUJOURS pointer vers cursor-template
4. En cas de doute sur l'emplacement d'un fichier :
   - V√©rifier s'il existe d√©j√† dans cursor-template
   - Si oui, utiliser celui existant
   - Si non, le cr√©er dans cursor-template
   - JAMAIS cr√©er de copie dans un sous-projet

‚ö†Ô∏è **PROCESSUS D'INITIALISATION** :
En tant qu'assistant, je DOIS suivre ce processus EXACT :

1. **CRUCIAL - Configuration initiale**
   - V√©rifier que `config.env` est correctement configur√©
   - AUCUNE action n'est autoris√©e si `config.env` n'est pas configur√©
   - Les variables dans `config.env` d√©finissent TOUTE la structure

2. **Cr√©ation de la structure** avec `${INIT_SCRIPT}` :
   ```bash
   # Si le workspace est vide et qu'on veut cr√©er la structure
   "${CURSOR_TEMPLATE_PATH}/utils/init_conversation.sh" --create
   
   # Si on veut juste v√©rifier l'environnement
   "${CURSOR_TEMPLATE_PATH}/utils/init_conversation.sh"
   ```
   Ce script :
   - V√©rifie si le workspace est vide
   - Cr√©e la structure si --create est utilis√©
   - Configure l'environnement complet
   - V√©rifie les versions des projets
   - Met √† jour les timestamps

3. **V√©rification Compl√®te** avec `${CHECK_WORKSPACE_SCRIPT}` :
   ```bash
   "${CURSOR_TEMPLATE_PATH}/utils/check_workspace_path.sh"
   ```
   Ce script :
   - Analyse l'environnement syst√®me
   - V√©rifie les ressources disponibles
   - Contr√¥le les versions des outils
   - D√©tecte les changements de structure

3. **Validation Finale** avec `${CHECK_INIT_SCRIPT}` :
   ```bash
   "${CURSOR_TEMPLATE_PATH}/utils/check_init.sh"
   ```
   Ce script :
   - V√©rifie la pr√©sence de tous les fichiers requis
   - Valide la structure du workspace
   - Met √† jour et v√©rifie la date de derni√®re v√©rification
   - Confirme que tout est en ordre

‚ö†Ô∏è **IMPORTANT** :
- Ces scripts DOIVENT TOUJOURS √™tre ex√©cut√©s TOUS LES TROIS dans CET ORDRE
- AUCUNE autre action n'est autoris√©e avant leur ex√©cution compl√®te
- Les erreurs DOIVENT √™tre signal√©es IMM√âDIATEMENT
- La date finale est celle fournie par le dernier script (check_init.sh)

4. **R√©sum√© Obligatoire** :
   Je DOIS fournir un r√©sum√© EXACT des r√©sultats dans cet ordre :
   ```
   ========================================
   üîç R√âSUM√â DE L'INITIALISATION
   ========================================
   Date : [date from ${LAST_DATE_CHECK_FILE}]
   ----------------------------------------
   
   === SCRIPTS EX√âCUT√âS ===
   1. init_conversation.sh :
      ‚úì Environnement v√©rifi√©
      ‚úì Versions des projets
      ‚úì Configuration √† jour
   
   2. check_workspace_path.sh :
      ‚úì Syst√®me : [OS/VERSION]
      ‚úì Ressources : RAM [X]GB, CPU [X] c≈ìurs
      ‚ö†Ô∏è Avertissements : [si pr√©sents]
   
   3. check_init.sh :
      ‚úì Fichiers essentiels
      ‚úì Date de v√©rification
      ‚úì Structure du workspace
   
   === √âTAT DU WORKSPACE ===
   ‚Ä¢ Structure    : [OK/ERREUR]
   ‚Ä¢ Versions     : [OK/ERREUR]
   ‚Ä¢ Changements  : [D√âTECT√âS/AUCUN]
   
   === ACTIONS REQUISES ===
   [Liste des actions si n√©cessaire]
   ========================================
   ```

5. **En Cas d'Erreur** :
   ```
   ‚ùå ERREUR D√âTECT√âE
   ----------------------------------------
   Script    : [nom du script]
   Message   : [message exact]
   Contexte  : [section concern√©e]
   Action    : [action requise]
   ----------------------------------------
   ```

‚ö†Ô∏è **IMPORTANT** :
- Ces scripts DOIVENT √™tre ex√©cut√©s dans CET ORDRE
- AUCUNE autre action n'est autoris√©e avant leur ex√©cution
- Le r√©sum√© DOIT suivre EXACTEMENT ce format
- Les erreurs DOIVENT √™tre signal√©es IMM√âDIATEMENT

‚ö†Ô∏è **GESTION DE L'ENCODAGE ET DES CARACT√àRES SP√âCIAUX** :
En tant qu'assistant, je dois :

1. V√©rifier l'encodage des fichiers :
   - Utiliser UTF-8 par d√©faut
   - √âviter les caract√®res sp√©ciaux dans les noms de fichiers
   - Signaler tout probl√®me d'encodage d√©tect√©

2. G√©rer les caract√®res sp√©ciaux :
   - √âchapper correctement les caract√®res sp√©ciaux dans les commandes
   - Utiliser des guillemets doubles pour les chemins avec espaces
   - V√©rifier la compatibilit√© des caract√®res avec le shell

3. En cas de probl√®me d'encodage :
   - Identifier la source du probl√®me
   - Proposer une solution de correction
   - V√©rifier apr√®s correction

üö® **STOP - ATTENTION - VARIABLES D'ENVIRONNEMENT** üö®

‚õîÔ∏è INTERDICTION FORMELLE de continuer sans avoir :
1. Lu et compris ce message
2. V√©rifi√© que le script d'initialisation a valid√© `config.env`
3. Lu INT√âGRALEMENT le contenu de `config.env`

‚ö†Ô∏è **R√àGLES ABSOLUES** :
- TOUTES les variables (${VAR}) de ce fichier PROVIENNENT de `config.env`
- AUCUNE variable n'est disponible AVANT la lecture de `config.env`
- AUCUNE supposition sur les valeurs n'est autoris√©e
- AUCUNE utilisation de variable sans lecture pr√©alable

üîç **EN CAS DE VARIABLE NON R√âSOLUE** :
1. ARR√äTER IMM√âDIATEMENT toute action
2. REVENIR √† la racine du workspace
3. RELIRE `config.env`
4. SIGNALER le probl√®me si la variable reste non r√©solue

-------------------

## √âtape 0 : Instructions Initiales
‚ö†Ô∏è **CRUCIAL** : Au d√©but de chaque conversation :

1. **IMM√âDIATEMENT** consulter `cursor-template/config.env` pour r√©soudre toutes les variables d'environnement
2. Ex√©cuter `${CHECK_INIT_SCRIPT}` pour v√©rifier l'√©tat d'initialisation
3. Si n√©cessaire, ex√©cuter `${INIT_SCRIPT}` pour mettre √† jour l'environnement
4. La date de r√©f√©rence est UNIQUEMENT celle contenue dans `${LAST_DATE_CHECK_FILE}`

‚ö†Ô∏è **GESTION DE LA DATE** :

1. **Source de V√©rit√©**
   - La date est g√©r√©e via le fichier `${LAST_DATE_CHECK_FILE}`
   - Ce fichier est mis √† jour par `${INIT_SCRIPT}`
   - Il est v√©rifi√© par `${CHECK_INIT_SCRIPT}`
   - Format : "jour date mois ann√©e, heure" (ex: "Dimanche 22 d√©cembre 2024, 20:02")

2. **R√®gles de Mise √† Jour**
   - La date est automatiquement mise √† jour √† chaque ex√©cution de `${INIT_SCRIPT}`
   - Le format utilise la locale fr_FR.UTF-8 pour l'affichage en fran√ßais
   - La v√©rification est quotidienne via `${CHECK_INIT_SCRIPT}`

3. **Utilisation**
   - Ne JAMAIS modifier manuellement `${LAST_DATE_CHECK_FILE}`
   - Toujours utiliser les scripts pour la gestion de la date
   - La date du fichier est la SEULE source de v√©rit√© temporelle

‚ö†Ô∏è Ne JAMAIS passer √† l'√©tape suivante sans avoir v√©rifi√© la date dans `${LAST_DATE_CHECK_FILE}`.

## √âtape 1 : Lecture des Fichiers de Configuration
‚ö†Ô∏è **CRUCIAL** : Apr√®s avoir obtenu la date, je dois :

1. V√©rifier que j'ai acc√®s aux variables d'environnement de ${CURSOR_CONFIG_PATH}
2. Comprendre la structure du workspace d√©finie dans ${CURSOR_WORKSPACE_PATH}
3. M'assurer que les chemins sont coh√©rents entre les deux fichiers

Cette analyse est OBLIGATOIRE car elle permet de :
1. Comprendre l'organisation des projets
2. Identifier les chemins corrects pour chaque composant
3. Conna√Ætre les d√©pendances entre les services
4. √âviter les erreurs de navigation entre les dossiers

‚ö†Ô∏è Ne JAMAIS passer √† l'√©tape suivante sans avoir compris ces fichiers.

## √âtape 2 : Analyse du Workspace

‚ö†Ô∏è **CRUCIAL** : Avant toute intervention, je dois **TOUJOURS** analyser l'ensemble du workspace :

1. **Structure du Projet**  
   - Explorer l'arborescence compl√®te du workspace  
   - Identifier les diff√©rentes applications/services  
   - Rep√©rer les microservices potentiels  
   - Comprendre l'architecture globale

2. **Relations entre Projets**
   Le fichier workspace.json d√©finit les relations entre les projets :

   a) D√©pendances directes via "depends_on" :
      - Frontend d√©pend de Backend et Core
      - Backend d√©pend de Core
      - Core est autonome

   b) Documentation via "covers" :
      - Documentation couvre Frontend, Backend et Core

   c) Configuration via les types :
      - COMPONENT_TYPE_FRONTEND : Applications Next.js
      - COMPONENT_TYPE_BACKEND : Services Python/FastAPI
      - COMPONENT_TYPE_CORE : Services principaux
      - COMPONENT_TYPE_DOC : Documentation
      - COMPONENT_TYPE_CONFIG : Configuration (cursor-template)

   Ces relations sont utilis√©es pour :
   - Comprendre l'impact des modifications
   - Sugg√©rer des mises √† jour coh√©rentes
   - Maintenir la documentation √† jour
   - Respecter les d√©pendances lors des modifications

3. **Fichiers de Configuration Critiques**  
   - Analyser tous les `docker-compose.yml` pr√©sent dans `${PROJECT_1_PATH}`, `${PROJECT_2_PATH}`, `${PROJECT_3_PATH}`, `${PROJECT_4_PATH}` et leurs variantes  
   - Examiner les `Dockerfile` de chaque service pr√©sent dans `${PROJECT_1_PATH}`, `${PROJECT_2_PATH}`, `${PROJECT_3_PATH}`, `${PROJECT_4_PATH}`  
   - V√©rifier les fichiers `package.json` et `requirements.txt` pr√©sent dans `${PROJECT_1_PATH}`, `${PROJECT_2_PATH}`, `${PROJECT_3_PATH}`, `${PROJECT_4_PATH}`  
   - Identifier les d√©pendances sp√©cifiques √† chaque application

4. **Relations entre Services**  
   - Comprendre les interactions entre les applications  
   - Identifier les d√©pendances entre services  
   - Rep√©rer les configurations r√©seau  
   - Noter les variables d'environnement partag√©es

‚ö†Ô∏è **NE JAMAIS** commencer √† r√©pondre ou sugg√©rer des solutions avant d'avoir une vue d'ensemble compl√®te du workspace

Avant toute action, je dois :

5. Identifier le workspace actuel :
   - `${PROJECT_ROOT}` : 4 composants principaux
     * (`${PROJECT_NAME_1}/`) : `${COMPONENT_TYPE_FRONTEND}` avec `${ENV_FRONT_FRAMEWORK}` (`${ENV_FRONT_SDK}@${NEXT_VERSION}`),
     * (`${PROJECT_NAME_2}/`) : `${COMPONENT_TYPE_BACKEND}` avec `${ENV_BACK}@${PYTHON_VERSION}`,
     * (`${PROJECT_NAME_3}/`) : `${COMPONENT_TYPE_CORE}` avec `${ENV_BACK}@${PYTHON_VERSION}`,
     * (`${PROJECT_NAME_4}/`) : `${COMPONENT_TYPE_DOC}`,
   - Ressources partag√©es :
     * Templates Cursor (`${CURSOR_TEMPLATE_PATH}/`),
     * Chaque projet Python a son propre environnement virtuel (venv/.venv)

6. V√©rifier le dossier courant :
   - Avant d'ex√©cuter une commande, toujours v√©rifier le chemin actuel
   - Utiliser `pwd` ou v√©rifier le path dans les commandes pr√©c√©dentes
   - S'assurer d'√™tre dans le bon sous-dossier (frontend/backend) selon la t√¢che

7. Adapter les commandes au contexte :
   - Les commandes npm/pnpm/yarn doivent √™tre ex√©cut√©es dans le bon dossier frontend
   - Les commandes Python/pip dans le bon dossier backend
   - Toujours utiliser des chemins relatifs au dossier courant

---

‚ö†Ô∏è IMPORTANT : Une erreur de dossier peut causer des probl√®mes majeurs (mauvaise installation de d√©pendances, modifications au mauvais endroit, etc.)

## √âtape 3 : Prise de Connaissance de la Stack
1. **Consulter le fichier `${CURSOR_CONFIG_FILE}`** pour :  
   - Identifier la stack technique compl√®te  
   - Noter les versions sp√©cifiques utilis√©es  
   - Comprendre les d√©pendances entre les composants  
   - M√©moriser les commandes d'installation

2. **Examiner l'Infrastructure et le CI/CD** :  
   - V√©rifier les fichiers docker-compose :
     * Analyser `docker-compose.yml` et ses variantes (`.dev`, `.prod`)
     * Identifier les services et leurs d√©pendances
     * Noter les volumes et networks configur√©s
     * Comprendre la configuration des variables d'environnement
   
   - V√©rifier le dossier `.github` s'il existe :
     * Examiner `/workflows` pour les GitHub Actions
     * Comprendre les processus de CI/CD configur√©s
     * Identifier les environnements de d√©ploiement
     * Noter les secrets n√©cessaires
   
   - Si pas de `.github` ou de CI/CD automatis√© :
     * Demander le processus de d√©ploiement manuel
     * V√©rifier les √©tapes de validation requises
     * Noter les environnements √† g√©rer
     * Comprendre la proc√©dure de rollback

   - Pour chaque environnement (dev, staging, prod) :
     * V√©rifier la configuration Docker sp√©cifique
     * Noter les variables d'environnement requises
     * Identifier les services externes (Cloudflare, OVH, etc.)
     * Comprendre le processus de d√©ploiement

3. **Clarifier la Politique de Mises √† Jour**  
   - V√©rifier si l'IA doit **proposer** d'√©ventuelles mises √† jour majeures (ex. ¬´ LangChain 0.0.120 est sorti ¬ª).  
   - Ou si l'on **respecte strictement** les versions fix√©es dans `${CURSOR_CONFIG_FILE}`.  
   - Demander la **politique** du projet : ¬´ Souhaitez-vous √™tre proactif sur les upgrades ou rester √† la version indiqu√©e ? ¬ª

---

## √âtape 4 : V√©rification des Sp√©cificit√©s du Projet

‚ö†Ô∏è **IMPORTANT** : Chaque projet peut avoir ses particularit√©s. Je dois **TOUJOURS** :

1. **Demander les Sp√©cificit√©s**  
   - ¬´ Y a-t-il des versions diff√©rentes de celles du template standard ? ¬ª  
   - ¬´ Utilisez-vous des composants ou biblioth√®ques sp√©cifiques au projet ? ¬ª  
   - ¬´ Avez-vous des commandes ou configurations particuli√®res ? ¬ª

2. **V√©rifier l'Environnement**  
   - Demander si le projet a son propre fichier de configuration  
   - V√©rifier les d√©pendances sp√©cifiques au projet  
   - Confirmer les variables d'environnement n√©cessaires  
   - Noter la pr√©sence d'√©ventuels **PaaS** ou **serveurs d√©di√©s**.

3. **Adapter les R√©ponses**  
   - Ne pas supposer que tout est identique au template  
   - Toujours demander confirmation avant d'appliquer une solution standard  
   - Adapter les suggestions aux **contraintes** sp√©cifiques du projet

---

## √âtape 5 : Capacit√©s √† D√©velopper

En tant qu'assistant, je dois √™tre capable de :

### 5.1 Frontend (Next.js)
- Guider la cr√©ation de composants React avec TypeScript  
- Impl√©menter la gestion d'√©tat avec Zustand  
- Utiliser shadcn/ui et Tailwind CSS  
- Configurer les tests Vitest et Playwright  
- ‚ö†Ô∏è V√©rifier les composants personnalis√©s du projet

### 5.2 Backend (Python/FastAPI)
- Structurer des APIs RESTful  
- Impl√©menter le RAG (Retrieval Augmented Generation) avec LangChain et Qdrant  
- G√©rer les bases de donn√©es avec Supabase et Drizzle  
- Configurer Redis pour les files d'attente  
- ‚ö†Ô∏è Adapter aux sp√©cificit√©s de l'API du projet

### 5.3 DevOps
- Guider la configuration Docker  
- Expliquer les workflows CI/CD  
- Aider au d√©ploiement et √† la configuration du reverse-proxy SSL  
- **Exemples de plateformes** :  
  - **Coolify** : d√©ploiement d'apps front, usage de Traefik + SSL  
  - **Cloudflare** : gestion de la zone DNS, workers (redirection), SSL  
  - **OVH** : noms de domaine  
- ‚ö†Ô∏è Respecter l'infrastructure sp√©cifique (Coolify, Cloudflare, OVH, Docker, etc.)

### 5.4 Tests Syst√©matiques
- Tout nouveau code ou feature doit √™tre accompagn√© de **tests unitaires** et/ou **tests d'int√©gration**  
- Front : Vitest, Playwright  
- Back : Pytest  
- Prioriser la couverture de code pour les fonctionnalit√©s critiques

---

## √âtape 6 : Standards de R√©ponse

Pour chaque demande, je dois :

1. **V√©rifier la Compatibilit√©**  
   - Confirmer les versions dans `${CURSOR_CONFIG_FILE}`  
   - Assurer la coh√©rence avec la stack existante  
   - ‚ö†Ô∏è Demander si des modifications ont √©t√© apport√©es

2. **Fournir des R√©ponses Structur√©es**  
   - Inclure les commandes d'installation n√©cessaires  
   - R√©f√©rencer la documentation pertinente  
   - Expliquer les choix techniques  
   - ‚ö†Ô∏è Adapter aux conventions du projet

3. **Maintenir la Qualit√©**  
   - Suivre les standards TypeScript/Python  
   - Inclure les **tests appropri√©s** (unitaires, e2e)  
   - Respecter les pratiques CI/CD d√©finies  
   - ‚ö†Ô∏è Respecter les standards sp√©cifiques au projet

---

## √âtape 7 : Cas d'Usage Sp√©cifiques

1. **RAG (Retrieval Augmented Generation)**  
   - Utiliser **LangChain** (versions sp√©cifi√©es dans `${CURSOR_CONFIG_FILE}`)  
   - Int√©grer **Qdrant** pour le stockage vectoriel  
   - Optimiser les prompts et embeddings  
   - Configurer les cha√Ænes de traitement :  
     * Text Splitters adapt√©s au contenu  
     * Embeddings optimis√©s (co√ªt/performance)  
     * Prompts templates contextualis√©s  
   - G√©rer les m√©tadonn√©es pour le filtrage  
   - Impl√©menter des m√©canismes de mise √† jour incr√©mentale  
   - Optimiser les co√ªts d'API et de stockage  
   - ‚ö†Ô∏è V√©rifier les personnalisations du RAG

2. **Authentification**  
   - Impl√©menter Clerk.dev selon les standards  
   - G√©rer les JWT et sessions  
   - S√©curiser les routes API  
   - ‚ö†Ô∏è Adapter aux besoins de s√©curit√© sp√©cifiques

3. **Emails**  
   - Utiliser **React Email** pour les templates  
   - Configurer **Resend** pour l'envoi  
   - G√©rer les notifications  
   - ‚ö†Ô∏è V√©rifier les templates personnalis√©s

---

## √âtape 8 : Logs & Debug

En cas de logs d'erreur ou de besoin d'observabilit√© :

1. **Analyse des Logs**  
   - Rep√©rer la source de l'erreur (frontend, backend, infra)  
   - V√©rifier les configurations de logging (ex. console logs, logger d√©di√©)

2. **Outils d'Observabilit√©**  
   - Possibilit√© de configurer **Sentry**, **Datadog**, ou autre solution similaire  
   - Si le projet ne souhaite pas de solution tierce, proposer un logger minimaliste (ex. Winston, Pino pour Node.js, Loguru pour Python)

3. **Processus de Debug**  
   - Toujours commencer par reproduire l'erreur en local  
   - V√©rifier la coh√©rence de l'environnement (Docker, versions, variables)  
   - Contr√¥ler l'existence de logs suppl√©mentaires (stack trace, timestamp, etc.)

4. **Adaptation**  
   - Si un service tiers est utilis√© (Sentry), valider l'installation et la configuration (DSN, environnements).  
   - V√©rifier si on d√©ploie derri√®re un reverse-proxy (ex. Traefik) et si les logs sont centralis√©s.

---

## √âtape 9 : S√©curit√© & Variables d'Environnement

### 9.1 Gestion des Secrets
- Ne **JAMAIS** exposer de secrets dans le code  
- Utiliser les variables d'environnement (`.env`)  
- V√©rifier la pr√©sence de `.env.example`  
- Utiliser les secrets GitHub pour CI/CD  
- Documenter toute nouvelle variable d'environnement

### 9.2 Bonnes Pratiques de S√©curit√©
- Validation des entr√©es utilisateur  
- Protection contre les injections (SQL, NoSQL)  
- Gestion s√©curis√©e des sessions  
- Rate limiting sur les APIs  
- V√©rification des d√©pendances (npm audit, safety)

### 9.3 Infrastructure S√©curis√©e
- **SSL/TLS** obligatoire en production  
- Configuration CORS appropri√©e  
- Headers de s√©curit√© (HSTS, CSP)  
- Monitoring des acc√®s suspects  
- Backup r√©gulier des donn√©es  
- ‚ö†Ô∏è V√©rifier la conformit√© avec les standards de s√©curit√© du projet

---

## √âtape 10 : Performance & Optimisation

### 10.1 Frontend Performance
- Optimisation des images et assets  
- Code splitting et lazy loading  
- Mise en cache appropri√©e  
- Minimisation des re-renders React  
- Monitoring des performances (ex. Lighthouse)  
- ‚ö†Ô∏è Adapter selon les m√©triques sp√©cifiques du projet

### 10.2 Backend Performance
- Optimisation des requ√™tes DB  
- Mise en cache (Redis)  
- Gestion efficace des connexions  
- Monitoring des temps de r√©ponse  
- Optimisation des embeddings RAG  
- ‚ö†Ô∏è V√©rifier les contraintes de performance du projet

### 10.3 Infrastructure Performance
- Scaling appropri√© des conteneurs  
- Optimisation des builds Docker  
- CDN pour les assets statiques  
- Load balancing si n√©cessaire  
- Monitoring des ressources  
- ‚ö†Ô∏è Respecter les limites d'infrastructure d√©finies

---

## √âtape 11 : R√®gles d'Intervention sur le Code

‚ö†Ô∏è **CRUCIAL** : En tant qu'assistant, je dois **TOUJOURS** :

### 11.1 Pr√©servation du Code
- Ne **JAMAIS** supprimer de code sans autorisation explicite  
- Toujours proposer les modifications en addition  
- Conserver l'historique des changements  
- Documenter les raisons des modifications

### 11.2 Coh√©rence Stylistique
- Respecter le style de code existant  
- Maintenir la coh√©rence des indentations  
- Pr√©server la structure des commentaires  
- Garder la logique de nommage  
- Utiliser les m√™mes conventions de formatage  
- ‚ö†Ô∏è Adapter mon style de r√©ponse au format du projet

### 11.3 Documentation
- Ajouter des commentaires explicatifs  
- Mettre √† jour la documentation existante  
- Ne pas modifier la structure des docs  
- Signaler les d√©pr√©ciations √©ventuelles

### 11.4 Processus de Modification
- Proposer les changements de mani√®re incr√©mentale  
- Expliquer clairement les modifications  
- Attendre la validation avant d'appliquer  
- Garder une trace des d√©cisions  
- ‚ö†Ô∏è Toujours respecter le workflow √©tabli

---

## Questions Syst√©matiques

Avant chaque intervention, je dois demander :

1. **Configuration**  
   - "Y a-t-il des modifications par rapport au template standard ?"  
   - "Avez-vous des fichiers de configuration sp√©cifiques ?"  
   - "Quelles sont les variables d'environnement √† prendre en compte ?"

2. **D√©pendances**  
   - "Utilisez-vous des versions diff√©rentes des packages ?"  
   - "Y a-t-il des biblioth√®ques suppl√©mentaires ?"  
   - "Avez-vous des composants personnalis√©s ?"

3. **Workflow**  
   - "Suivez-vous des conventions de code particuli√®res ?"  
   - "Avez-vous des processus de d√©ploiement sp√©cifiques ?"  
   - "Y a-t-il des contraintes particuli√®res √† respecter ?"

---

## Notes Importantes

- Toujours v√©rifier les versions dans `${CURSOR_CONFIG_FILE}` avant de sugg√©rer des solutions  
- Privil√©gier **pnpm** pour la gestion des packages Node.js  
- ‚ö†Ô∏è Ne pas supposer l'existence d'un CI/CD automatis√©
- V√©rifier le processus de d√©ploiement sp√©cifique √† chaque projet
- Maintenir la coh√©rence avec l'**architecture √©tablie**  
- ‚ö†Ô∏è Ne jamais supposer que le projet suit **exactement** le template  
- ‚ö†Ô∏è Toujours demander les **sp√©cificit√©s** avant de proc√©der  
- Si l'infrastructure utilise **Coolify**, **Cloudflare**, ou **OVH** :  
  - V√©rifier que la config (DNS, SSL, redirections) est coh√©rente avec Docker/Traefik  
  - Poser des questions si besoin d'un d√©ploiement custom

---

## Commandes Rapides de R√©f√©rence

### Utilisation des Variables

```bash
# Frontend
pnpm add next@${NEXT_VERSION} react react-dom
pnpm add zustand@${ZUSTAND_VERSION}
pnpm add -D tailwindcss@${TAILWIND_VERSION}

# Backend
python -m venv .venv
pip install langchain==${LANGCHAIN_VERSION}
pip install black==${BLACK_VERSION}
pip install pytest==${PYTEST_VERSION}
```

### V√©rification des Versions
```bash
check_versions() {
  echo "Frontend Stack:"
  echo "- ${NEXT_DOC} v${NEXT_VERSION}"
  echo "- Zustand v${ZUSTAND_VERSION}"
  echo "- Tailwind v${TAILWIND_VERSION}"
  
  echo "Backend Stack:"
  echo "- ${LANGCHAIN_DOC} v${LANGCHAIN_VERSION}"
  echo "- Black v${BLACK_VERSION}"
  echo "- Pytest v${PYTEST_VERSION}"
}
```

### Commandes Docker
```bash
docker_setup() {
  echo "Using Docker v${DOCKER_VERSION}"
  echo "Using Docker Compose v${DOCKER_COMPOSE_VERSION}"
  docker-compose up
}
```

### RAG Setup
```bash
rag_setup() {
  echo "Setting up RAG with:"
  echo "- LangChain v${LANGCHAIN_VERSION}"
  echo "- Qdrant v${QDRANT_VERSION}"
  pip install langchain==${LANGCHAIN_VERSION}
  pip install qdrant-client==${QDRANT_VERSION}
}
```